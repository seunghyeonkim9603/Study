## 정수 표현법

### 방법 1: 부호 절대값 표기법

최상위 비트를 부호비트로 사용하고   
하위 비트들의 바이너리 패턴을 그대로 정수를 표현하는데 사용   
#### 부호 절대값 표기법의 한계
1. 부호비트를 제외한 비트들이 0일 때의 값이 같음 = 0이 2개   
2. 양수와 음수를 서로 더할 때 비트 패턴 둘을 더하는 것만으로 안됨   
  - 컴퓨터는 사칙연산 중에 덧셈만 가능

이에 따라 다른 방법이 필요함   
### 방법 2: 2의 보수사용
최상위 비트를 부호비트로 사용하고 음수값을 표현할 때 2의 보수를 사용   
2의 보수를 사용하면 2진수의 덧셈 만으로도 뺄셈이 가능함   
보수를 사용하는 이유   
컴퓨터는 **덧셈밖에 할줄 모르기 때문**   
 - 폰 노이만이 뺄셈을 위해 2의 보수를 사용할 것을 제안함   

보수와 오버플로를 이용한 뺄셈   
10의 보수 뺄셈   
00012 - 00003 = 00012 + 99997 = 1 00009 = 00009   
2의 보수 뺄셈   
10011 - 00111 = 10011 + 11001 = 1 01100 = 01100   

- - -

## 문자

### 아스키
최초의 아스키는 1byte 에 128개의 문자를 표현   
최상위 비트 한개는 오류 검증용으로 사용   
   
### ANSI
라틴 문자를 표시하기 위해 만든 문자 인코딩 방식 ansi   
아스키에서 오류 검증용 비트까지 문자를 표기하기 위해 사용   
   
### 멀티바이트
한국어, 일본어, 중국어 등 을 위한 멀티바이트 문자 인코딩   
euc-kr euc-cn euc-jp   
같은 바이너리 패턴인데 다른 나라 언어를 표현 가능   
**멀티바이트의 한계**   
 - 여러 언어를 한번에 표현 못함   
   
### 유니코드
전세계의 모든 문자 및 이모지 까지 표현할 수 있는 규격    
세상 모든 문자에 번호를 붙임   
유니코드 인코딩의 종류   
utf-8 utf-16 utf-32   
차이는 최소 바이트 수   
   
### ucs-2
최초의 유니코드 인코딩   
utf-16의 전신   
2바이트에 세상 모든 문자를 넣을 수 있다는 믿음에서 탄생   
   
C#이나 java의 string은 UTF-16   
   
### UTF-8을 쓰자
현재 모든 웹페이지의 93%는 UTF-8   
메모리를 적게씀   
인코딩 디코딩이 쉬움   
엔디안 문제가 없음   
아스키 코드와 100%호환   
   
- - -

## 실수 표현
   
### 고정 소수점 수   
요즘 많이 쓰는 포맷은 아니지만 이해할 만한 가치가 있음   
표현할 수 있는 범위의 값은 확실히 표현 가능   
따라서 **오차가 없어야 하는 제품에 적합** (예 : 은행)   
예전에는 CPU에서 실수 계산을 해주는 전담장치가 없었기에   
고정소수점 수를 직접 구현해서 쓰는 경우가 많았음   
### 단점   
1. 표현 가능한 수의 범위가 작아짐   
2. 그렇다고 정수부분을 늘리면 소수점을 정밀히 표현 불가   
3. 근대의 CPU에 달린 실수 계산 전담 장치는 고정소수점 수를 지원 안 함   
4. 최근 언어에서 자체적으로 지원하는 경우도 드묾   
5. 연산 뒤 정밀도 손실 및 오버플로 발생 가능성 높음   
   
### 부동 소수점 수   
소수점을 움직여서 표현 가능한 범위가 늘어남   
하지만 정밀도를 희생   
장점   
1. 근대 CPU, 웬만한 프로그래밍 언어에서 IEE754표준을 지원  
2. 부동소수점의 장점은 고정소수점의 단점 
   
32비트 부동 소수점수   
부호비트 1비트 지수 비트 8비트 가수 비트 23비트로 실수를 표현   
![single_precison](~@C:\Users\alme2\OneDrive\바탕 화면\seunghyeonkim9603\Computer Architecture)







